//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.4

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "attribute")]
pub enum Attribute {
    #[sea_orm(string_value = "white")]
    #[serde(rename = "white")]
    White,
    #[sea_orm(string_value = "black")]
    #[serde(rename = "black")]
    Black,
}

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "sharing")]
pub enum Sharing {
    #[sea_orm(string_value = "TLP:Red")]
    #[serde(rename = "TLP:Red")]
    TlpRed,
    #[sea_orm(string_value = "TLP:Amber+Strict")]
    #[serde(rename = "TLP:Amber+Strict")]
    TlpAmberStrict,
    #[sea_orm(string_value = "TLP:Amber")]
    #[serde(rename = "TLP:Amber")]
    TlpAmber,
    #[sea_orm(string_value = "TLP:Green")]
    #[serde(rename = "TLP:Green")]
    TlpGreen,
    #[sea_orm(string_value = "TLP:Clear")]
    #[serde(rename = "TLP:Clear")]
    TlpClear,
}

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "source")]
pub enum Source {
    #[sea_orm(string_value = "official")]
    #[serde(rename = "official")]
    Official,
    #[sea_orm(string_value = "local")]
    #[serde(rename = "local")]
    Local,
}

impl TryFrom<&str> for Attribute {
    type Error = String;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        match s {
            "white" => Ok(Attribute::White),
            "black" => Ok(Attribute::Black),
            _ => Err(format!("Invalid attribute: {}", s)),
        }
    }
}

impl AsRef<str> for Attribute {
    fn as_ref(&self) -> &str {
        match self {
            Attribute::White => "white",
            Attribute::Black => "black",
        }
    }
}

impl TryFrom<&str> for Sharing {
    type Error = String;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        match s {
            "TLP:Red" => Ok(Sharing::TlpRed),
            "TLP:Amber+Strict" => Ok(Sharing::TlpAmberStrict),
            "TLP:Amber" => Ok(Sharing::TlpAmber),
            "TLP:Green" => Ok(Sharing::TlpGreen),
            "TLP:Clear" => Ok(Sharing::TlpClear),
            _ => Err(format!("Invalid sharing level: {}", s)),
        }
    }
}

impl AsRef<str> for Sharing {
    fn as_ref(&self) -> &str {
        match self {
            Sharing::TlpRed => "TLP:Red",
            Sharing::TlpAmberStrict => "TLP:Amber+Strict",
            Sharing::TlpAmber => "TLP:Amber",
            Sharing::TlpGreen => "TLP:Green",
            Sharing::TlpClear => "TLP:Clear",
        }
    }
}

impl TryFrom<&str> for Source {
    type Error = String;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        match s {
            "official" => Ok(Source::Official),
            "local" => Ok(Source::Local),
            _ => Err(format!("Invalid source type: {}", s)),
        }
    }
}

impl AsRef<str> for Source {
    fn as_ref(&self) -> &str {
        match self {
            Source::Official => "official",
            Source::Local => "local",
        }
    }
}